ActiveMq实战-限时订单
解决办法：
1.定时任务轮询扫描
    轮询数据库在实现限时订单上是可行的，而且实现起来很简单。写个定时器去每隔一段时间扫描数据库，检查到订单过期了，做适当的业务处理。
    但是轮询会带来什么问题？
    1、轮询大部分时间其实是在做无用功，我们假设一张订单是45分钟过期，每分钟我们扫描一次，对这张订单来说，要扫描45次以后，才会检查到这张订单过期，这就意味着数据库的资源（连接，IO）被白白浪费了；
    2、处理上的不及时，一个待支付的电影票订单我们假设是12:00:35过期，但是上次扫描的时间是12:00:30，那么这个订单实际的过期时间是什么时候？12:01:30，和我本来的过期时间差了55秒钟。放在业务上，会带来什么问题？这张电影票，假设是最后一张，有个人12:00:55来买票，买得到吗？当然买不到了。那么这张电影票很有可能就浪费了。如果缩短扫描的时间间隔，第一只能改善不能解决，第二，又会对数据库造成更大的压力。
    那么我们能否有种机制，不用定时扫描，当订单到期了，自然通知我们的应用去处理这些到期的订单呢？

    代码：无，整合到实际的定时任务中就好了
    优点：实现简单
    缺点：需要扫描数据库，大部分时间都是做无用功，浪费数据库的链接资源。
2.使用DelayQueue无界阻塞队列
    java其实已经为我们提供了问题的方法。我们想，要处理限时支付的问题，肯定是要有个地方保存这些限时订单的信息的，意味着我们需要一个容器，于是我们在Java容器中去寻找。Map? List? Queue?
    看看java为我们提供的容器，我们是个多线程下的应用，会有多个用户同时下订单，所以所有并发不安全的容器首先被排除，并发安全的容器有哪些？一一排除，很巧，java在阻塞队列里为我们提供了一种叫延迟队列delayQueue的容器，刚好可以为我们解决问题。
    DelayQueue： 阻塞队列（先进先出）
    1）支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。2）支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。
    延迟期满时才能从中提取元素（光队列里有元素还不行）。
    Delayed接口使对象成为延迟对象，它使存放在DelayQueue类中的对象具有了激活日期。该接口强制实现下列两个方法。
    CompareTo(Delayed o)：Delayed接口继承了Comparable接口，因此有了这个方法。让元素按激活日期排队
    getDelay(TimeUnit unit):这个方法返回到激活日期的剩余时间，时间单位由单位参数指定。

    代码：具体实现在DqMode，SaveOrder引用
        @Autowired
        @Qualifier("dq")//jdk自带的DelayeQueue
        private IDelayOrder delayOrder;
    优点：jdk自带的DelayQueue
    缺点：1.当服务挂掉或重启之后，保存在DelayQueue中的数据会丢失（是保存在内存中的）。
            解决办法：需要服务启动的时候去扫描订单表，查询未支付的订单做如下处理：如果已过期未支付，那么更新状态为已过期，了如果未过期未支付，就再次放入DelayQueue中
            代码：SaveOrder.initDelayOrder
         2.如果服务是集群的，那么上面的解决办法，会导致每一台服务都会去处理同样的订单数据。
            解决办法：可以在订单表中加一个字段，区分是哪台服务存入的数据（如存服务名，或者ip地址）,每台服务启动的时候就处理该机器保存的数据
         3.这又会有一个问题，当某一台服务器死活启动不起来怎么办？
            解决办法：手工干预，手工修改服务器的ip
3.使用mq
    1.在activemq.xml中加入设置属性 schedulerSupport="true"
    2.在生产者中新增： textMessage.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY,expireTime);
    代码：具体实现在MqProvider,MqConsumer，SaveOrder引用
        @Autowired
        @Qualifier("mq")//使用消息队列
        private IDelayOrder delayOrder;
    优点：与引用程序解耦，伸缩性和扩展性好，当新增业务的时候基本不用动原来的代码（对应java里面的开闭原则，对扩展开放对修改关闭）
    缺点：当activemq挂掉的时候，就出问题了
        解决办法：activemq集群
